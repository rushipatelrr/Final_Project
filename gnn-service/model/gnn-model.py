# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qw3-u69gQLaI7NH0XlNeM2T82nX6p48a
"""

!pip install torch torchvision torchaudio --quiet
!pip install torch_geometric scikit-learn --quiet

import pandas as pd
import numpy as np

from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.neighbors import NearestNeighbors
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity

import torch
from torch import nn
import torch.nn.functional as F
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv

df = pd.read_csv("unique_food_dataset_1300.csv")
df.head()
df.shape

orders_norm = (df['orders'] - df['orders'].min()) / (df['orders'].max() - df['orders'].min())
rating_norm = (df['rating'] - df['rating'].min()) / (df['rating'].max() - df['rating'].min())

df['popularity'] = 0.6 * orders_norm + 0.4 * rating_norm

df[['item_id', 'name', 'orders', 'rating', 'popularity']].head()

categorical_cols = ["food_type", "cuisine", "taste_profile"]
numeric_cols = ["spice_level", "orders", "rating", "popularity"]
encoder = OneHotEncoder(sparse_output=False)
cat_features = encoder.fit_transform(df[categorical_cols])

scaler = StandardScaler()
num_features = scaler.fit_transform(df[numeric_cols])

X = np.hstack([cat_features, num_features])

print("Feature matrix:", X.shape)

k = 10
nn_model = NearestNeighbors(n_neighbors=k+1, metric="euclidean")
nn_model.fit(X)
distances, indices = nn_model.kneighbors(X)

edges = []

for i in range(len(df)):
    for j in indices[i][1:]:
        edges.append([i, j])
        edges.append([j, i])

edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
edge_index.shape

x = torch.tensor(X, dtype=torch.float)
y = torch.tensor(df['rating'].values, dtype=torch.float).unsqueeze(1)
num_nodes = x.size(0)

train_idx, val_idx = train_test_split(
    np.arange(num_nodes),
    test_size=0.2,
    random_state=42
)

train_mask = torch.zeros(num_nodes, dtype=torch.bool)
val_mask = torch.zeros(num_nodes, dtype=torch.bool)

train_mask[train_idx] = True
val_mask[val_idx] = True

data = Data(
    x=x,
    edge_index=edge_index,
    y=y,
    train_mask=train_mask,
    val_mask=val_mask
)

class FoodGNN(nn.Module):
    def __init__(self, in_channels, hidden=64, emb=32):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden)
        self.conv2 = GCNConv(hidden, emb)

        self.regressor = nn.Sequential(
            nn.Linear(emb, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

    def forward(self, x, edge_index):
        x = F.relu(self.conv1(x, edge_index))
        x = F.dropout(x, p=0.2, training=self.training)
        x = F.relu(self.conv2(x, edge_index))

        self.emb = x

        rating_pred = self.regressor(x)
        return rating_pred, x

device = "cuda" if torch.cuda.is_available() else "cpu"
model = FoodGNN(in_channels=x.size(1)).to(device)
data = data.to(device)

optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
criterion = nn.MSELoss()

def train_epoch():
    model.train()
    optimizer.zero_grad()
    out, _ = model(data.x, data.edge_index)

    loss = criterion(out[data.train_mask], data.y[data.train_mask])
    loss.backward()
    optimizer.step()
    return loss.item()

@torch.no_grad()
def evaluate():
    model.eval()
    out, _ = model(data.x, data.edge_index)
    return criterion(out[data.val_mask], data.y[data.val_mask]).item()

for epoch in range(1, 61):
    train_loss = train_epoch()
    val_loss = evaluate()
    if epoch % 10 == 0:
        print(f"Epoch {epoch} | Train Loss = {train_loss:.4f} | Val Loss = {val_loss:.4f}")

@torch.no_grad()
def get_embeddings():
    model.eval()
    _, emb = model(data.x, data.edge_index)
    return emb.cpu().numpy()

embeddings = get_embeddings()
embeddings.shape

def get_top_popular(n=10):
    return df.sort_values("popularity", ascending=False).head(n)

from collections import defaultdict

adj = defaultdict(list)
for i, j in edges:
    adj[i].append(j)

def get_neighbors(item_id, k=5):
    idx = df.index[df["item_id"] == item_id][0]
    neighbors = adj[idx][:k]
    return df.iloc[neighbors][["item_id", "name", "popularity"]]

def recommend_for_new_user(top_n=5):
    top_items = get_top_popular(top_n)

    final_output = {}
    for _, row in top_items.iterrows():
        item_name = row["name"]
        item_id = row["item_id"]
        neighbors = get_neighbors(item_id)
        final_output[item_name] = neighbors

    return final_output

recommend_for_new_user(5)

torch.save(model.state_dict(), "gnn_model.pt")

embeddings = get_embeddings()

emb_df = pd.DataFrame(embeddings)
emb_df["item_id"] = df["item_id"].values
emb_df["name"] = df["name"].values
emb_df.to_csv("food_item_embeddings.csv", index=False)

